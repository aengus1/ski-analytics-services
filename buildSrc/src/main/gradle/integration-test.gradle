task integrationTest(type: Test) {

    def isRoot = (rootProject == project)

//    onlyIf {
//        !isRoot && sourceSetIsNotEmpty('integrationTest')
//    }

    useJUnitPlatform()
    // explicitly include or exclude tests
    include 'ski/crunch/**'


    // show standard out and standard error of the test JVM(s) on the console
    testLogging.showStandardStreams = false

    // set heap size for the test JVM(s)
    minHeapSize = "128m"
    maxHeapSize = "512m"

    // set JVM arguments for the test JVM(s)
    jvmArgs '-XX:MaxPermSize=256m'

    // listen to events in the test execution lifecycle
    beforeTest { descriptor ->
        logger.lifecycle("Running integration test: $descriptor")
    }

    // Fail the 'test' task on the first test failure
    failFast = true

    // listen to standard out and standard error of the test JVM(s)
    onOutput { descriptor, event ->
        logger.lifecycle(event.message)
    }


    description = 'Runs the integration tests.'
    group = 'verification'

    doFirst {
//        if (sourceSetIsNotEmpty('integrationTest')) {
//            testClassesDirs = sourceSets.integrationTest.output
//            classpath = sourceSets.integrationTest.runtimeClasspath
//            outputs.upToDateWhen { false }
//            binaryResultsDirectory = file("$buildDir/test-results/integrationTest/binary")
//        }
        final SourceSet sourceSet = sourceSets.find {
            it.name.equals('integrationTest')
        }
        println "SS -> " + sourceSet.name
        if (sourceSet != null) {
            testClassesDirs = sourceSet.output
            classpath = sourceSet.runtimeClasspath
            //outputs.upToDateWhen { false }
            //binaryResultsDirectory = file("$buildDir/test-results/integrationTest/binary")
        }
    }
    jacoco {
        destinationFile = file("$buildDir/jacoco/integrationTest.exec")

    }

    reports {
        junitXml.enabled = false
        html.enabled = true
        //html.destination = file("$buildDir/reports/int-test-results/html")
    }

}

task integrationTestReport(type: TestReport) {
    destinationDir = file("${buildDir}/reports/integration-tests")
    reportOn integrationTest.binaryResultsDirectory
}

integrationTest.finalizedBy integrationTestReport

task jacocoIntegrationTestReport(dependsOn: integrationTest, type: JacocoReport) {
    group = 'report'
    description = 'Generate Jacoco coverage reports after running integration tests.'
    executionData file("${buildDir}/jacoco/integrationTest.exec")
    additionalSourceDirs.from = files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories.from = files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories.from = files(subprojects.sourceSets.main.output)

    reports {
        csv.enabled = false
        xml.enabled = true
        html.enabled = true
        html.setDestination(new File("${buildDir}/reports/jacoco/integration-test/html"))
        //html.destination = "${buildDir}/reports/jacoco/integration-test/html"
        //xml.destination = "${buildDir}/reports/jacoco/integration-test/jacocoIntegrationTestReport.xml"
    }
}

def sourceSetIsNotEmpty(String sourceSetName) {
    final SourceSet sourceSet = sourceSets.find {
        it.name.equals(sourceSetName)
    }

    return null != sourceSet &&
            (0 < sourceSet.compileClasspath.size()
                    || 0 < sourceSet.runtimeClasspath.size())
}