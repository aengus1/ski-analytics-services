plugins {
    id 'scala'
    id 'java'
    id 'jacoco'
}


/**
 * To get joint compilation, you have to add some Java sources to the “scala” source directory set,
 * and at the same time take them away from the “java” source directory set. For example,
 * inif you want everything to be joint-compiled, do this:
 *
 * sourceSets.main.scala.srcDir "src/main/java"
 * sourceSets.main.java.srcDirs = []
 * Now both the Scala and Java code will be compiled by the compileScala task.
 */
sourceSets {
    main {
        scala {
            srcDirs = ['src/main/scala', 'src/main/java']
        }
        java {
            srcDirs = []
        }
    }
    integrationTest {
        scala {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDirs = ['src/integration-test/scala', 'src/integration-test/java']
        }
        java {
            compileClasspath += sourceSets.main.output + configurations.testCompile
            runtimeClasspath += sourceSets.main.output + compileClasspath + configurations.testCompile
            srcDirs = ['src/integration-test/java']
        }
        resources.srcDir file('src/integration-test/resources')
    }
}

configurations {
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime
}

dependencies {
    compile(
            'org.scala-lang:scala-library:2.11.12',
            'com.amazonaws:aws-lambda-java-core:1.1.0',
            'com.amazonaws:aws-java-sdk-s3:1.11.510',
            'com.amazonaws:aws-java-sdk-dynamodb:1.11.166',
            'com.amazonaws:aws-java-sdk-cloudformation:1.11.166',
            'com.amazonaws:aws-java-sdk-cognitoidp:1.11.442',
            'com.amazonaws:aws-java-sdk-ssm:1.11.163',
            'com.amazonaws:aws-lambda-java-log4j:1.0.0',
            'com.fasterxml.jackson.core:jackson-core:2.8.5',
            'com.fasterxml.jackson.core:jackson-databind:2.8.5',
            'com.fasterxml.jackson.core:jackson-annotations:2.8.5',
            'com.google.protobuf:protobuf-java:3.5.0',
            'commons-io:commons-io:2.5',
            "com.vividsolutions:jts:1.13",
            "org.geotools:gt-main:16.1",
            "org.geotools:gt-epsg-hsql:16.1",
            //project(':layers')

    )
    //compile project(':layers')

    testImplementation(
            'org.scalatest:scalatest_2.11:3.0.0',
            'org.junit.jupiter:junit-jupiter-api:5.1.0',
            // https://mvnrepository.com/artifact/com.sun.jersey/jersey-client
            'org.glassfish.jersey.core:jersey-client:2.5.1',
            'com.fasterxml.jackson.core:jackson-core:2.9.7',
            'org.mockito:mockito-all:1.10.19'
    )
    testRuntimeOnly(
            'org.junit.jupiter:junit-jupiter-engine:5.1.0'
    )
    integrationTestCompile(
            'org.scalatest:scalatest_2.11:3.0.0',
            'org.junit.jupiter:junit-jupiter-api:5.1.0',
            // https://mvnrepository.com/artifact/com.sun.jersey/jersey-client
            'org.glassfish.jersey.core:jersey-client:2.5.1',
            'com.fasterxml.jackson.core:jackson-core:2.9.7',
            'org.mockito:mockito-all:1.10.19'
    )
    integrationTestRuntime(
            'org.junit.jupiter:junit-jupiter-engine:5.1.0'
    )
}

test {
    useJUnitPlatform()

    // explicitly include or exclude tests
    include 'ski/crunch/**'


    // show standard out and standard error of the test JVM(s) on the console
    testLogging.showStandardStreams = true

    // set heap size for the test JVM(s)
    minHeapSize = "128m"
    maxHeapSize = "512m"

    // set JVM arguments for the test JVM(s)
    jvmArgs '-XX:MaxPermSize=256m'

    // listen to events in the test execution lifecycle
    beforeTest { descriptor ->
        logger.lifecycle("Running test:  $descriptor")
    }

    // Fail the 'test' task on the first test failure
    failFast = true

    // listen to standard out and standard error of the test JVM(s)
    onOutput { descriptor, event ->
        logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message)
    }

    // workingDir = new File('src/test/')
}


jacoco {
    toolVersion = "0.8.2"
    reportsDir = file("$buildDir/coverage")

}

jacocoTestCoverageVerification {
//    afterEvaluate {
//        classDirectories = files(classDirectories.files.collect {
//            fileTree(dir: it, exclude:  [
//                    'com/garmin/fit/**',
//                    'ski/crunch/activity/model/*'
//            ])
//        })
//    }
}
jacocoTestReport {
    reports {
        xml.enabled = true
        csv.enabled = false
        html.destination file("${buildDir}/coverage/")
    }


    afterEvaluate {
        classDirectories = files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ['com/garmin/**', 'ski/crunch/activity/model/**'])
        })
    }
}


task integrationTest(type: Test) {

    useJUnitPlatform()
    // explicitly include or exclude tests
    include 'ski/crunch/**'


    // show standard out and standard error of the test JVM(s) on the console
    testLogging.showStandardStreams = true

    // set heap size for the test JVM(s)
    minHeapSize = "128m"
    maxHeapSize = "512m"

    // set JVM arguments for the test JVM(s)
    jvmArgs '-XX:MaxPermSize=256m'

    // listen to events in the test execution lifecycle
    beforeTest { descriptor ->
        logger.lifecycle("Running integration test: " + descriptor)
    }

    // Fail the 'test' task on the first test failure
    failFast = true

    // listen to standard out and standard error of the test JVM(s)
    onOutput { descriptor, event ->
        logger.lifecycle(event.message)
    }


    description = 'Runs the integration tests.'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output
    classpath = sourceSets.integrationTest.runtimeClasspath
    outputs.upToDateWhen { false }
}

check.dependsOn integrationTest
integrationTest.mustRunAfter test
test.finalizedBy jacocoTestReport

/**
 * Builds the zip file for upload to AWS
 */
task buildZip(type: Zip) {
    baseName = "api"
    from compileJava
    from compileScala
    from processResources
    exclude "layers.jar"
    into('lib') {
        from configurations.runtime
    }
}

build.dependsOn buildZip
/**
 * Deploys the build to the staging environment
 */
task deployStaging(type: Exec) {
    environment 'PATH', "${environment.PATH}:/usr/local/bin"

    commandLine 'sls', 'deploy', '-v'
}
deployStaging.dependsOn build


task wrapper(type: Wrapper) {
    gradleVersion = '3.5'
}