apply plugin: 'java'
apply plugin: 'ski.crunch.build.deploy'

dependencies {

    compileOnly(project(':common'))  //exclude from packaged artifact -> provided at runtime by lambda container
    implementation(
            "com.amazonaws:aws-lambda-java-events:2.2.6",
            "com.auth0:java-jwt:3.8.0",
            "com.auth0:jwks-rsa:0.8.2"
    )

    integrationTestImplementation(
            "com.amazonaws:aws-java-sdk-cloudformation:${awsVersion}",
            "org.junit.jupiter:junit-jupiter-api:5.4.0",
            "org.glassfish.jersey.core:jersey-client:2.5.1",
            "com.fasterxml.jackson.core:jackson-core:${jacksonVersion}",
            "org.mockito:mockito-all:1.10.19",
            "org.java-websocket:Java-WebSocket:1.4.0",
            project(path: ':common', configuration: 'testClasses'),
            project(':common')
    )
    integrationTestRuntimeOnly(
            "org.junit.jupiter:junit-jupiter-engine:5.4.0",
            project(':common')

    )

    /**
     * I'm still not sure why this is necessary.  Just adding the common project to this configuration should suffice
     *
     */
    String commonLibDir = "${projectDir}/../common/build/libs/"
    testImplementation(
            "org.mockito:mockito-all:1.10.19",
            project(':common'),
            fileTree(dir: commonLibDir, include: ['common-all.jar'])
    )



}
test {
    include 'ski/crunch/**'
}


deploy.dependencies = ['common']

// Task for building the zip file for upload
task buildZip(type: Zip) {

    // set the base name of the zip file
    archiveBaseName = "${project.name}"
    from compileJava
    from processResources
    into('lib') {
        from([configurations.runtimeClasspath] - [configurations.compileOnly])

    }
}

build.dependsOn buildZip

